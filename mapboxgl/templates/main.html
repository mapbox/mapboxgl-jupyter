<!DOCTYPE html>
<html>
<head>
<title>mapboxgl-jupyter viz</title>
<meta charset='UTF-8' />
<meta name='viewport'
      content='initial-scale=1,maximum-scale=1,user-scalable=no' />
<script type='text/javascript'
        src='https://api.tiles.mapbox.com/mapbox-gl-js/{{ gl_js_version }}/mapbox-gl.js'></script>
<link type='text/css'
      href='https://api.tiles.mapbox.com/mapbox-gl-js/{{ gl_js_version }}/mapbox-gl.css' 
      rel='stylesheet' />

<style type='text/css'>
    body { margin:0; padding:0; }
    .map { position: absolute; top:0; bottom:0; width:100%; }

    .legend {
        background-color: {{ legendFill|default("white") }};
        color: {{ legendTextColor|default("black") }};
        border-radius: 3px;
        bottom: 10px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.10);
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        padding: 0;
        position: absolute;
        right: 10px;
        z-index: 1;
        min-width: 100px;
    }
   .legend.horizontal {bottom: 10px; text-align: left;}

    /* legend header */
    .legend .legend-header { border-radius: 3px 3px 0 0; background: {{ legendHeaderFill|default("white") }}; }
    .legend .legend-title {
        padding: 6px 12px 6px 12px;
        text-shadow: 0 0 2px {{ legendTitleHaloColor|default("white") }};
        text-transform: capitalize;
        text-align: center;
        font-weight: bold !important;
        font-size: 14px;
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        max-width: 160px;
    }
    .legend-title {padding: 6px 12px 6px 12px; text-shadow: 0 0 2px #FFF; text-transform: capitalize; text-align: center; max-width: 160px; font-size: 0.9em; font-weight: bold;}
    .legend.horizontal .legend-title {text-align: left;}

    /* legend items */
    .legend-content {margin: 6px 12px 6px 12px; overflow: hidden; padding: 0; float: left; list-style: none; font-size: 0.8em;}
    .legend.horizontal.step ul.legend-content {font-size: 0.5em;}
    .legend.horizontal.step ul.legend-content li.legend-item .legend-value {line-height: 1.5em;}
    .legend.vertical .legend-item {white-space: nowrap;}
    .legend-value {display: inline-block; line-height: 18px; vertical-align: top;}
    .legend.horizontal ul.legend-content li.legend-item .legend-value,
    .legend.horizontal ul.legend-content li.legend-item {display: inline-block; float: left; width: 30px; margin-bottom: 0; text-align: center; min-height: 30px;}

    /* legend key styles */
    .legend-key {display: inline-block; height: 10px;}
    .legend-key.default, .legend-key.square {border-radius: 0;}
    .legend-key.circle {border-radius: 50%;}
    .legend-key.rounded-square {border-radius: 20%;}
    .legend.vertical .legend-key {width: 10px; margin-right: 5px; margin-left: 1px;}
    .legend.horizontal .legend-key {width: 30px; margin-right: 0; margin-top: 1px; float: left;}
    .legend.horizontal .legend-key.square, .legend.horizontal .legend-key.rounded-square, .legend.horizontal .legend-key.circle {margin-left: 10px; width: 10px;}
    .legend.horizontal .legend-key.line {margin-left: 5px;}
    .legend.horizontal .legend-key.line, .legend.vertical .legend-key.line {border-radius: 10%; width: 20px; height: 3px; margin-bottom: 2px;}

    /* gradient bar alignment */
    .gradient-bar {margin: 6px 12px 6px 12px;}
    .legend.horizontal .gradient-bar {width: 88%; height: 10px;}
    .legend.vertical .gradient-bar {width: 10px; min-height: 50px; position: absolute; bottom: 4px;}

    /* contiguous vertical bars (discrete) */
    .legend.vertical.contig .legend-key {height: 15px; width: 10px;}
    .legend.vertical.contig li.legend-item {height: 15px;}
    .legend.vertical.contig {padding-bottom: 6px;}

    /* vertical radius legend */
    .legend.horizontal.legend-variable-radius ul.legend-content li.legend-item .legend-value,
    .legend.horizontal.legend-variable-radius ul.legend-content li.legend-item {width: 30px; min-height: 20px;}

    /* scale annotation */
    .mapboxgl-ctrl.mapboxgl-ctrl-scale { border-color: {{ scaleBorderColor }}; 
                                         background-color: {{ scaleFillColor }}; 
                                         color: {{ scaleTextColor }}; }
</style>

{% block extra_css %}{% endblock extra_css %}

</head>
<body>

<div id='map' class='map'></div>

<script type='text/javascript'>

var legendHeader,
    legendContent,
    legendTitle;


function initLegend(legend, title, legendIndex, legendFunction, legendKeyShape) {

    // assign legend class
    if (legendFunction === 'radius') {
        legend.className = 'legend {{ legendLayout|default("vertical") }} legend-variable-radius';
    }
    else if (legendKeyShape === 'contiguous-bar') {
        legend.className = 'legend {{ legendLayout|default("vertical") }} contig';
    }
    else {
        legend.className = 'legend {{ legendLayout|default("vertical") }}';
    }

    legend.id = 'legend-' + legendIndex;
    document.body.appendChild(legend);

    // add legend header and content elements
    legendTitle = document.createElement('div');
    legendTitle.textContent = title;
    legendTitle.className = 'legend-title'

    legendHeader = document.createElement('div');
    legendHeader.className = 'legend-header'
    legendHeader.appendChild(legendTitle);

    legendContent = document.createElement('ul');
    legendContent.className = 'legend-content'

    legend.appendChild(legendHeader);
    legend.appendChild(legendContent);

}


function calcRadiusLegend(myRadiusStops, title, color) {

    // maximum legend item height
    var legend = document.createElement('div'),
        maxLegendItemHeight = 2 * myRadiusStops[myRadiusStops.length - 1][1];

    // create legend
    initLegend(legend, title, 1, 'radius', 'circle');

    // calculate a legend entries on a Mapbox GL Style Spec property function stops array
    for (p = 0; p < myRadiusStops.length; p++) {
        if (!!document.getElementById('legend-radius-points-value-' + p)) {
            //update the legend if it already exists
            document.getElementById('legend-radius-points-value-' + p).textContent = myRadiusStops[p][0];
            document.getElementById('legend-radius-points-id-' + p).style.backgroundColor = color;
        }
        else {
            // create the legend if it doesn't yet exist
            var item = document.createElement('li');
            item.className = 'legend-item';
            item.height = '' + maxLegendItemHeight + 'px';

            var key = document.createElement('span');
            key.className = 'legend-key {{ legendKeyShape|default("circle") }}';
            key.id = 'legend-radius-points-id-' + p;
            key.style.backgroundColor = color;   

            key.style.width = '' + myRadiusStops[p][1] * 2 + 'px';
            key.style.height = '' + myRadiusStops[p][1] * 2 + 'px';

            keyVerticalMargin = (maxLegendItemHeight - myRadiusStops[p][1] * 2) * 0.5;
            key.style.marginTop = '' + keyVerticalMargin + 'px';
            key.style.marginBottom = '' + keyVerticalMargin + 'px';

            var value = document.createElement('span');
            value.className = 'legend-value';
            value.id = 'legend-radius-points-value-' + p;

            item.appendChild(key);
            item.appendChild(value);
            legendContent.appendChild(item);
            
            data = document.getElementById('legend-radius-points-value-' + p)

            // round number values in legend if precision defined
            if ((typeof(myRadiusStops[p][0]) == 'number') && (typeof({{ legendNumericPrecision }}) == 'number')) {
                data.textContent = myRadiusStops[p][0].toFixed({{ legendNumericPrecision }});
            }
            else {
                data.textContent = myRadiusStops[p][0];
            }
        }
    }

    // add class for styling bordered legend keys
    if ({{ legendKeyBordersOn|safe }}) {
        var keys = document.getElementsByClassName('legend-key');
        for (var i=0; i < keys.length; i++) {
            if (keys[i]) {
                keys[i].classList.add('bordered');
            }
        }
    }

    // update right-margin for compact Mapbox attribution based on calculated legend width
    updateAttribMargin(legend);
    updateLegendMargin(legend);

}


function addLegendItem(legendContent, itemIndex, keyShape, precision, defaultColor, colorStops, colorFunctionType) {

    // create the legend item if it doesn't yet exist
    var item = document.createElement('li');
    item.className = 'legend-item';

    // create the legend key (contains symbol for legend item)
    var key = document.createElement('span');
    key.className = 'legend-key ' + keyShape;
    key.id = 'legend-color-points-id-' + itemIndex;

    // determine the color to use for step color functions
    if (colorFunctionType === 'step') {

        if (itemIndex===0) {
            key.style.backgroundColor = defaultColor;
        }
        else if (itemIndex === colorStops.length) {
            key.style.backgroundColor = colorStops[itemIndex-1][1];
        }
        else {
            key.style.backgroundColor = colorStops[itemIndex-1][1];
        }

    }
    // determine the color to use for other color functions 
    else {
        key.style.backgroundColor = colorStops[itemIndex][1];
    }

    // determine the legend item label
    var value = document.createElement('span');
    value.className = 'legend-value';
    value.id = 'legend-color-points-value-' + itemIndex;
    item.appendChild(key);
    item.appendChild(value);
    legendContent.appendChild(item);
    
    data = document.getElementById('legend-color-points-value-' + itemIndex);

    if (colorFunctionType === 'step' && itemIndex === colorStops.length) {
        var useStop = colorStops[itemIndex-1][0];
    }
    else {
        var useStop = colorStops[itemIndex][0];
    }

    // round number values in legend if precision defined
    if ((typeof(useStop) == 'number') && (typeof(precision) == 'number')) {
        data.textContent = useStop.toFixed(precision);
    }
    else {
        data.textContent = useStop;
    }

    // update legend key text for step color functions
    if (colorFunctionType === 'step') {

        if (itemIndex === 0) {
            data.textContent = '< ' + data.textContent;
        }

        else if (itemIndex < colorStops.length) {

            if ((typeof(colorStops[itemIndex][0]) == 'number') && (typeof(precision) == 'number')) {
                prepend = colorStops[itemIndex-1][0].toFixed(precision);
            }
            else {
                prepend = colorStops[itemIndex-1][0];
            }

            data.textContent = prepend + ' - ' + data.textContent;

        }

        else {

            data.textContent = '> ' + data.textContent;

        }

    }

}


function calcColorLegend(myColorStops, title, colorFunctionType, defaultColor) {

    // create legend
    var legend = document.createElement('div'),
        // legendContainer = document.getElementsByClassName('mapboxgl-ctrl-bottom-right')[0],
        legendKeyShape = '{{ legendKeyShape|default("circle") }}';

    initLegend(legend, title, 0, 'color', legendKeyShape);


    if ({{ legendGradient|safe }} === true) {
        var gradientText = 'linear-gradient(to right, ',
            gradient = document.createElement('div');
        gradient.className = 'gradient-bar';
        legend.appendChild(gradient);
    }
    // calculate a legend entries on a Mapbox GL Style Spec property function stops array
    for (p = 0; p < myColorStops.length; p++) {

        // update the legend if it already exists
        if (!!document.getElementById('legend-color-points-value-' + p)) {
            document.getElementById('legend-color-points-value-' + p).textContent = myColorStops[p][0];
            document.getElementById('legend-color-points-id-' + p).style.backgroundColor = myColorStops[p][1];
        }

        // create the legend item if it doesn't yet exist
        else {
            addLegendItem(legendContent, 
                          p, 
                          legendKeyShape, 
                          {{ legendNumericPrecision }}, 
                          defaultColor, 
                          myColorStops, 
                          colorFunctionType);
               
            // add color stop to gradient list
            if ({{ legendGradient|safe }} === true) {
                if (p < myColorStops.length - 1) {
                    gradientText = gradientText + myColorStops[p][1] + ', ';
                }
                else {
                    gradientText = gradientText + myColorStops[p][1] + ')';
                }
                if ('{{ legendLayout|default("vertical") }}' === 'vertical') {
                    gradientText = gradientText.replace('to right', 'to bottom');
                }
            }
        }
    }

    // add last legend item for step-type expressions
    if (colorFunctionType === 'step') {

        legend.className = legend.className + ' step';

        addLegendItem(legendContent, 
                      p, 
                      legendKeyShape, 
                      {{ legendNumericPrecision }}, 
                      defaultColor, 
                      myColorStops, 
                      colorFunctionType);        
    }

    // gradient bar styling
    if ({{ legendGradient|safe }} === true) {
        // convert to gradient scale appearance
        gradient.style.background = gradientText;
        // hide legend keys generated above
        var keys = document.getElementsByClassName('legend-key');
        for (var i=0; i < keys.length; i++) {
            keys[i].style.visibility = 'hidden';
        }
        if ('{{ legendLayout|default("vertical") }}' === 'vertical') {
            gradient.style.height = (legendContent.offsetHeight - 6) + 'px';
        }
    }
    // add class for styling bordered legend keys
    if ({{ legendKeyBordersOn|safe }}) {
        var keys = document.getElementsByClassName('legend-key');
        for (var i=0; i < keys.length; i++) {
            if (keys[i]) {
                keys[i].classList.add('bordered');
            }
        }
        var gradientBars = document.getElementsByClassName('gradient-bar');
        for (var i=0; i < keys.length; i++) {
            if (gradientBars[i]) {
                gradientBars[i].classList.add('bordered');
            }
        }
    }
    // update right-margin for compact Mapbox attribution based on calculated legend width
    updateAttribMargin(legend);
    updateLegendMargin(legend);
}


function updateAttribMargin(legend) {

    // default margin is based on calculated legend width
    var attribMargin = legend.offsetWidth + 15;
    
    // if horizontal legend layout (multiple legends are stacked vertically)
    if ('{{ legendLayout|default("vertical") }}' === 'horizontal') {
        document.getElementsByClassName('mapboxgl-ctrl-attrib')[0].style.marginRight = (attribMargin).toString() + 'px';
    }
    // vertical legend layout means multiple legends are side-by-side
    else if ('{{ legendLayout|default("vertical") }}' === 'vertical') {
        var currentMargin = Number(document.getElementsByClassName('mapboxgl-ctrl-attrib')[0].style.marginRight.replace('px', ''));
        document.getElementsByClassName('mapboxgl-ctrl-attrib')[0].style.marginRight = (attribMargin + currentMargin).toString() + 'px';
    }
}


function updateLegendMargin(legend) {

    var verticalLegends = document.getElementsByClassName('legend vertical'),
        horizontalLegends = document.getElementsByClassName('legend horizontal');

    if (verticalLegends.length > 1) {
        for (i = 1; i < verticalLegends.length; i++) {
            verticalLegends[i].style.marginRight = (legend.offsetWidth - 5).toString() + 'px';
            var legend = verticalLegends[i];
        }
    }
    else if (horizontalLegends.length > 1) {
        for (i = 1; i < horizontalLegends.length; i++) {
            horizontalLegends[i].style.marginBottom = (legend.offsetHeight + 15).toString() + 'px';
            var legend = horizontalLegends[i];
        }
    }
}


function generateInterpolateExpression(propertyValue, stops) {
    var expression;
    if (propertyValue == 'zoom') {
        expression = ['interpolate', ['exponential', 1.2], ['zoom']]
    }
    else if (propertyValue == 'heatmap-density') {
        expression = ['interpolate', ['linear'], ['heatmap-density']]
    }
    else {
        expression = ['interpolate', ['linear'], ['get', propertyValue]]
    }

    for (var i=0; i<stops.length; i++) {
        expression.push(stops[i][0], stops[i][1])
    }
    return expression
}


function generateMatchExpression(propertyValue, stops, defaultValue) {
    var expression;
    expression = ['match', ['get', propertyValue]]
    for (var i=0; i<stops.length; i++) {
        expression.push(stops[i][0], stops[i][1])
    }
    expression.push(defaultValue)
    
    return expression
}


function generateStepExpression(propertyValue, stops, defaultValue) {
    var expression;
    expression = ['step', ['get', propertyValue], defaultValue]
    for (var i=0; i<stops.length; i++) {
        expression.push(stops[i][0], stops[i][1])
    }
    return expression
}


function generatePropertyExpression(expressionType, propertyValue, stops, defaultValue) {
    var expression;
    if (expressionType == 'match') {
        expression = generateMatchExpression(propertyValue, stops, defaultValue)
    }
    else if (expressionType == 'identity') {
        expression = ['get', propertyValue]
    }
    else if (expressionType == 'step') {
        expression = generateStepExpression(propertyValue, stops, defaultValue)
    }
    else {
        expression = generateInterpolateExpression(propertyValue, stops)
    }

    return expression
}

</script>

<!-- main map creation code, extended by mapboxgl/templates/{{ viz }}.html -->
<script type="text/javascript">{% block javascript %}{% endblock %}</script>

<!-- add capability to export map or legend to image file -->
{% if includeSnapshotLinks %}
    <script src="https://github.com/niklasvh/html2canvas/releases/download/v1.0.0-alpha.12/html2canvas.min.js" charset="utf-8"></script>
    {% include 'export_canvas.html' %}
{% endif %}

</body>
</html>
